require(MASS)
require(psych)
require(matrixcalc)
require(Matrix)
require(plyr)
require(LaplacesDemon)
require(mnormt)
require(mombf)

#' Batch effect correction using Bayesian factor regression.
#'
#' @param x n x p matrix of p observations for n individuals
#' @param v n x p_v matrix of known covariates.
#' @param b n x p_b matrix of batch indicator.
#' @param q latent cardinality.
#' @param eps margin for convergence.
#' @param it maximum number of iterations.
#' @param prior Spike prior to use for the laodings: "N.MOM", "Normal" or "Flat".
#' @param seed random seed to use.
#' @param scaling mean centering the data?
#' @param init list of initial parameters.
#' @param hyper list of hyper parameters.
#' @param varianceBE TRUE if location batch correction is added; FALSE if not.
#' @param intercept adds intercept to the Bayesian factor regression.
#' @return A list with the optimised parameters.
#' @examples
#' add(1, 1)
#' add(10, 1)

#####General algorithm###
BFA.EM.BE <- function(x,v=NULL,b=NULL,q=2,eps=0.0001,it=100,epsM=0.05,
                      prior="N.MOM",varianceBE=TRUE,init=NULL,hyper=NULL,
                      seed=4,scaling=FALSE,intercept=FALSE,varimax=FALSE){

  set.seed(seed)

  if (scaling==TRUE) x<-scale(x)

  if(is.null(hyper)){
    if(prior=="N.MOM"){
      l0<-.1/qnorm(.975)^2
      l1<-0.284215
      #l0<-0.00473483
      #l1<-293.9898
      #l0<-0.00551287
      #l1<-114.4926
      #l0<-0.012294171
      #l1<-572.8865
    }else{
      l0<-.1/qnorm(.975)^2
      l1<-0.8526451
      #l0<-0.0234969
      #l1<-(16*log(0.05)/qnorm(.025))^2
      #l0<-3429/(34295*log(19))
      #l1<-3429/(5*log(19))
      #l0<-0.0636759
      #l1<-1165.43
    }
    hyper=list(theta=0.5,
               aS = 1,
               bS = 1,
               l0 = l0,
               l1 = l1,
               at = 1,
               bt = 1,
               MuT = 0,
               sigmaT = 1)
  }

  n<-nrow(x)
  p<-ncol(x)
  p_b<-1
  w_b<-1
  sorted.index<-c(1:n)
  if (!is.null(b)) {p_b=ncol(b)
  n_b=apply(b,2,sum)
  w_b=n_b/n
  sorted.index.aux <- 1
  for(i in 1:p_b){
    sorted.index.aux <- c(sorted.index.aux,sorted.index[b[,i]==1])
  }
  sorted.index<-sorted.index.aux[-1]
  if (intercept==FALSE){
    if(!is.null(v)){
      v=cbind(v,b)
    }else{
      v=b
    }
    }
  }
  if (intercept==TRUE){
    if(!is.null(v)){
      v_0=rep(1,n)
      if(!is.null(b)){
        v=cbind(v_0,v,b[,-p_b])
      }else{
        v=cbind(v_0,v)
      }
    }
  }
  if(!is.null(v)){
    p_v<-ncol(v)
  }else{p_v<-1}

  #Hyperparameters
  g.theta = hyper$theta
  aS = hyper$aS
  bS = hyper$bS
  l0 = hyper$l0
  l1 = hyper$l1
  at = hyper$at
  bt = hyper$bt
  MuT = hyper$MuT
  sigmaT = hyper$sigmaT

  ## initialization of M sigma and theta
  if (is.null(init)) {
    if(!is.null(v)){
      fm1 <- lm(x ~ v)
      theta <- t(fm1$coefficients[-1,])
      #Replacing NA for zeros
      theta[is.na(theta)] <- 0
      #stima<-try(factanal(fm1$residuals,r,rotation="none"),silent=TRUE)
      svd.X <- svd(fm1$residuals)
      svd.U <- svd.X$u
      svd.V <- svd.X$v
      Lambda <- diag(svd.X$d)
      if(n>=q){
        sigma2 <- 1/(p-q) * sum(svd.U[(q+1):p])                                                          # variance; average variance associated with discarded dimensions
        aux_p <- min(n,p)
        if(is.positive.definite(Lambda-sigma2*diag(aux_p))==FALSE){
          aux.chol <- matrix(ncol=n,nearPD(Lambda-sigma2*diag(aux_p))$mat)
        }else{aux.chol <- Lambda-sigma2*diag(aux_p)}
        M<-(svd.V %*% chol(aux.chol) %*% diag(aux_p))[,1:q]
      }else{
        #Reconstruction x=svd.U%*%Lambda%*%t(svd.V)%*%svd.V%*%t(svd.V) PC=svd.U%*%Lambda%*%t(svd.V) M'=svd.V%*%t(svd.V)
        M<-svd.V%*%t(svd.V)[,1:q]
      }
    }else{
      theta <- rep(0,p)
      svd.X <- svd(x)
      svd.U <- svd.X$u
      svd.V <- svd.X$v
      Lambda <- diag(svd.X$d)
      if(n>=q){
        sigma2 <- 1/(p-q) * sum(svd.U[(q+1):p])                                                          # variance; average variance associated with discarded dimensions
        aux_p <- min(n,p)
        if(is.positive.definite(Lambda-sigma2*diag(aux_p))==FALSE){
          aux.chol <- matrix(ncol=n,nearPD(Lambda-sigma2*diag(aux_p))$mat)
        }else{aux.chol <- Lambda-sigma2*diag(aux_p)}
        M<-(svd.V %*% chol(aux.chol) %*% diag(aux_p))[,1:q]
      }else{
        #Reconstruction x=svd.U%*%Lambda%*%t(svd.V)%*%svd.V%*%t(svd.V) PC=svd.U%*%Lambda%*%t(svd.V) M'=svd.V%*%t(svd.V)
        M<-svd.V%*%t(svd.V)[,1:q]
      }
    }
    if(varimax==TRUE){
      M<-varimax(M+0.0000001)$loadings
    }
    z<-mvrnorm(n = n, rep(0,q), diag(q))
    sigma<-diag(p)
    #g.theta <- rep(g.theta,p)
    g.theta <- rep(g.theta,q)
    if(prior=="N.MOM"){
      #gamma <- E.gamma.pMOM(M,sigma,l0,l1,g.theta)
      gamma <- E.gamma.pMOM(M,l0,l1,g.theta)
    }else{
      #gamma <- E.gamma.2(M,sigma,l0,l1,g.theta)
      gamma <- E.gamma.2(M,l0,l1,g.theta)
    }
    D <- gamma$d
    p.gamma <- gamma$p

  } else {
    theta<-init$theta
    sigma<-init$sigma
    M<-init$M
    z<-init$z
    D <- init$D
    p.gamma <- init$p.gamma
    g.theta <- init$g.theta}

  ##traces
  trace_sigma <- matrix(nrow =1, ncol = p*p_b,diag(sigma))
  trace_theta <- matrix(nrow =1, ncol = p*p_v,c(theta))
  trace_M <- matrix(nrow = 1, ncol = p*q,c(M))
  trace_D <- matrix(nrow = 1, ncol = p*q,c(D))
  trace_p <- matrix(nrow = 1, ncol = p*q,c(p.gamma))
  trace_g.theta <- matrix(nrow = 1, ncol = q,c(g.theta))

  #tracesaux
  trace_priorGammaGtheta <- 0
  trace_priorMpMOM <- 0

  #####EM#####
  count<-1
  likelihood<-NULL
  change<-1000
  changeM<-1000
  wait<-0
  #lik<--100000000000
  if(!is.null(v)){
    x_o <- x
    x<-x_o-v%*%t(theta)
    tv <- t(v)
    I.pv <- diag(p_v)
    #vv_inv <- solve(tv%*%v+I.pv)
  }
  I.q <- diag(q)

  likelihood<-likelihoodFA(x,M,sigma)
  logprior_aux<-logpriorFAall(M,diag(sigma),theta,g.theta,p.gamma,D,hyper,prior)
  logprior<-logprior_aux$lTotal
  logpriorM <- logprior_aux$lM
  logpriorsigma <- logprior_aux$lsigma
  logpriorTheta <- logprior_aux$lTheta
  logpriorGammaGtheta <- logprior_aux$lGammaGtheta
  logpost<-logprior + likelihood
  lik<-logpost

  trace_like <- likelihood
  trace_like2 <- likelihood
  trace_prior <- logprior
  trace_post <- logpost
  trace_priorM <- logpriorM
  trace_priorsigma <- logpriorsigma
  trace_priorTheta <- logpriorTheta
  if(!prior=="Flat"){
    trace_priorGammaGtheta <- logpriorGammaGtheta
  }

  if(varianceBE==FALSE){
    sigma_aux=rep(1,p)
  }else{sigma_aux=matrix(1,p,p_b)}

  while ((count < it) & ((changeM > epsM ) & (change > eps ))) {
    #print(count)
    ##E step
    #Ez<-E.Z(x,as.matrix(M),sigma,q,p)
    if (varianceBE==FALSE){
      Ez<-E.Z(x,as.matrix(M),diag(sigma),I.q)
      Ez.x<-Ez$z
      Ezz.x<-Ez$zz
      Ezz.list<-Ezz.x
    }
    if (varianceBE==TRUE){
      #Ezz.x<-0
      Ez.x<-c(1:q)
      Ezz.list<-list()
      for (i in 1:p_b){
        Ez<-E.Z(x[c(1:n)[b[,i]==1],],as.matrix(M),sigma_aux[,i],I.q)
        Ez.x<-rbind(Ez.x,Ez$z)
        #Ezz.x<-Ez$zz + Ezz.x
        Ezz.list[[i]]<-Ez$zz
      }
      #sort them
      Ez.x<-Ez.x[-1,]
      Ez.x<-Ez.x[order(sorted.index),]
      #Add Ezz
      Ezz.x = Reduce('+', Ezz.list)
    }

    if(prior=="N.MOM"){
      #gamma <- E.gamma.pMOM(M,sigma,l0,l1,g.theta)
      gamma <- E.gamma.pMOM(M,l0,l1,g.theta)
      D <- gamma$d
      p.gamma <- gamma$p
    }
    if(prior=="Normal"){
      #gamma <- E.gamma.2(M,sigma,l0,l1,g.theta)
      gamma <- E.gamma.2(M,l0,l1,g.theta)
      D <- gamma$d
      p.gamma <- gamma$p
    }

    #LOF
    #D <- lof(D,p.gamma)
    #p.gamma <- lof(p.gamma,p.gamma)
    #D2 <- lof(D2,p.gamma)
    #D3 <- lof(D3,p.gamma)

    ##M-step
    M.old<-M
    if(prior=="N.MOM"){
      #M<-M.pMOM.cda.2(x,Ez.x,Ezz.list,D,M.old,p.gamma,sigma_aux,b)
      M<-M.pMOM.cda.3(x,Ez.x,Ezz.list,D,M.old,p.gamma,sigma_aux,b)
      #if(count==1){M<-varimax(M)$loadings}
    }
    if(prior=="Normal"){
      M<-M.new(x,Ez.x,Ezz.list,D,b,sigma_aux)
      #if(count==1){M<-varimax(M)$loadings}
    }
    if(prior=="Flat"){
      #M<-M.new.NS(x,Ez.x,Ezz.x)
      M<-M.new.NS.2(x,Ez.x,Ezz.list,b,sigma_aux)
    }

    #Does it maximise?
    # if (varianceBE==FALSE){
    #   likelihood.new<-likelihoodFA(x,M,sigma)
    # }else{
    #   like.aux<-llply(.data = 1:p_b, .fun = function(y){
    #     likelihoodFA(x[c(1:n)[b[,y]==1],],M,diag(sigma_aux[,y]))
    #   }, .parallel = FALSE)
    #   likelihood.new<-sum(do.call("rbind", like.aux))
    # }
    # logprior_aux.new<-logpriorFAall(M,sigma_aux,theta,g.theta,p.gamma,D,hyper,prior)
    # if((lik)>(logprior_aux.new$lTotal+likelihood.new)){
    #   M<-M.old
    # }

    tM <- t(M)
    #Varimax
    # if(varimax==TRUE){
    #   M.var<-varimax(M+0.0000001)$loadings
    #   wait<-wait+1
    #   R<-varimax(M+0.0000001)$rotmat
    #   #Does it maximise?
    #   if (varianceBE==FALSE){
    #     likelihood.var<-likelihoodFA(x,M.var,sigma)
    #     likelihood.new<-likelihoodFA(x,M,sigma)
    #   }else{
    #     like.aux<-llply(.data = 1:p_b, .fun = function(y){
    #       likelihoodFA(x[c(1:n)[b[,y]==1],],M.var,diag(sigma_aux[,y]))
    #     }, .parallel = FALSE)
    #     likelihood.var<-sum(do.call("rbind", like.aux))
    #     like.aux<-llply(.data = 1:p_b, .fun = function(y){
    #       likelihoodFA(x[c(1:n)[b[,y]==1],],M,diag(sigma_aux[,y]))
    #     }, .parallel = FALSE)
    #     likelihood.new<-sum(do.call("rbind", like.aux))
    #   }
    #   logprior_aux.var<-logpriorFAall(M.var,sigma_aux,theta,g.theta,p.gamma,D,hyper,prior)
    #   logprior_aux.new<-logpriorFAall(M,sigma_aux,theta,g.theta,p.gamma,D,hyper,prior)
    #   if((logprior_aux.var$lTotal+likelihood.var)>(logprior_aux.new$lTotal+likelihood.new)){
    #       M<-M.var
    #     }
    #   if(wait==varimax){wait=0}
    # }

    if (varianceBE==FALSE){
      # if(prior=="N.MOM"){
      #   sigma<-sigma.pMOM(x,Ez.x,Ezz.x,M,D,aS,bS,p.gamma,n)
      # }
      # if(prior=="Normal"){
      #   #sigma<-sigma.new(x,Ez.x,Ezz.x,M,D,aS,bS,n)
      #   sigma<-sigma.new(x,Ez.x,Ezz.x,M,aS,bS)
      # }
      if(prior=="Flat"){
        sigma<-sigma.new.NS(x,Ez.x,Ezz.x,M,aS,bS)
      }else{
        sigma<-sigma.new(x,Ez.x,Ezz.x,M,aS,bS)
      }
      sigma_aux<-diag(sigma)
    }else{
      for (i in 1:p_b){
        x_b<-x[c(1:n)[b[,i]==1],]
        z_b<-Ez.x[c(1:n)[b[,i]==1],]
        sigmaInv <- diag(1/sigma_aux[,i])
        W_b<-solve(I.q + tM%*%sigmaInv%*%M)
        zz_b<-t(z_b)%*%z_b+n_b[i]*W_b
        # if(prior=="N.MOM"){
        #   sigma_aux[,i]<-diag(sigma.pMOM(x_b,z_b,zz_b,M,D,aS,bS,p.gamma,n))
        # }
        # if(prior=="Normal"){
        #   # sigma_aux[,i]<-diag(sigma.new(x_b,z_b,zz_b,M,D,aS,bS,n))
        #   sigma_aux[,i]<-diag(sigma.new(x_b,z_b,zz_b,M,aS,bS))
        # }
        if(prior=="Flat"){
          sigma_aux[,i]<-diag(sigma.new.NS(x_b,z_b,zz_b,M,aS,bS))
        }else{
          sigma_aux[,i]<-diag(sigma.new(x_b,z_b,zz_b,M,aS,bS))
        }
      }
      sigma<-diag(c(sigma_aux %*% w_b))
    }

    if(!is.null(v)){
      #theta<-Theta.new(x_o,vv_inv,tv,Ez.x,M)
      theta<-Theta.new.prior(x_o,v,b,Ez.x,M,sigma_aux,sigmaT)
      x<-x_o-v%*%theta
      trace_theta <- rbind(trace_theta,c(t(theta)))
    }

    if(!prior=="Flat"){
      g.theta <- theta.gamma.new.2(p.gamma,at,bt)
      #g.theta <-M_theta_NLP(p.gamma,at/q)
    }

    #Saving values
    trace_sigma <- rbind(trace_sigma,c(sigma_aux))
    trace_M <- rbind(trace_M,c(M))
    if(!prior=="Flat"){
      trace_D <- rbind(trace_D,c(D))
      trace_p <- rbind(trace_p,c(p.gamma))
      trace_g.theta <- rbind(trace_g.theta,c(g.theta))
    }

    ### Rotation
    #if(count<10){
    #  sigmaInv_aux <- diag(1/diag(sigma_aux),p)
    #  W <- chol2inv(chol(I.q + tM%*%sigmaInv_aux%*%M+(.0000001*diag(q))))
    #  A<-chol(W+(t(Ez.x)%*%(Ez.x)*1/n))
    #  M <- M%*%A
    #}

    ##Likelihood
    #likelihood<-likelihoodFA(x,M,sigma)
    if (varianceBE==FALSE){
      likelihood<-likelihoodFA(x,M,sigma)
      likelihood2<-likelihood
      # if(!is.null(v)){
      #   likelihood2<-likelihoodFA2(x_o,v%*%theta+Ez.x%*%t(M),sigma)
      # }else{likelihood2<-likelihood}
      }else{
      like.aux<-llply(.data = 1:p_b, .fun = function(y){
        likelihoodFA(x[c(1:n)[b[,y]==1],],M,diag(sigma_aux[,y]))
        #likelihoodFA2(x_o[c(1:n)[b[,y]==1],],v[c(1:n)[b[,y]==1],]%*%theta+Ez.x[c(1:n)[b[,y]==1],]%*%t(M),diag(sigma_aux[,y]))
      }, .parallel = FALSE)
      likelihood<-sum(do.call("rbind", like.aux))
      likelihood2<-likelihood
      # if(!is.null(v)){
      #   like.aux2<-llply(.data = 1:p_b, .fun = function(y){
      #     #likelihoodFA(x[c(1:n)[b[,y]==1],],M,diag(sigma_aux[,y]))
      #     likelihoodFA2(x_o[c(1:n)[b[,y]==1],],v[c(1:n)[b[,y]==1],]%*%theta+Ez.x[c(1:n)[b[,y]==1],]%*%t(M),diag(sigma_aux[,y]))
      #   }, .parallel = FALSE)
      #   likelihood2<-sum(do.call("rbind", like.aux2))
      # }else{likelihood2<-likelihood}
    }

    logprior_aux<-logpriorFAall(M,sigma_aux,theta,g.theta,p.gamma,D,hyper,prior)

    logprior<-logprior_aux$lTotal
    logpriorM <- logprior_aux$lM
    logpriorsigma <- logprior_aux$lsigma
    logpriorTheta <- logprior_aux$lTheta
    logpriorGammaGtheta <- logprior_aux$lGammaGtheta
    logpost <- likelihood+logprior
    #change<-likelihood-lik
    #lik<-likelihood
    #change<-abs(logpost-lik)
    #change<-logpost-lik
    change<-abs(logpost-lik)
    changeM<-max(abs(M.old-M))
    #change<-logpost-lik
    #if(change<0) change<-(eps+1)
    lik<-logpost
    trace_like<-c(trace_like,likelihood)
    trace_like2<-c(trace_like2,likelihood2)
    trace_prior<-c(trace_prior,logprior)
    trace_post<-c(trace_post,logpost)
    trace_priorM <- c(trace_priorM,logpriorM)
    trace_priorsigma <- c(trace_priorsigma,logpriorsigma)
    trace_priorTheta <- c(trace_priorTheta,logpriorTheta)
    trace_priorGammaGtheta <- c(trace_priorGammaGtheta,logpriorGammaGtheta)
    count<-count+1
    #print(count)
    #print(logpriorM)
    #print(round(change,3))
    #print(round(changeM,3))

    # if(plot){myImagePlot(as.matrix(M),F)
    #   myImagePlot(as.matrix(p.gamma),F)
    #   }


  }

  return(list(M=M,
              sigma=sigma_aux,
              Ez=Ez.x,
              Ezz=Ezz.x,
              Theta=t(theta),
              gTheta = g.theta,
              gamma = p.gamma,
              D = D,
              tracesigma=trace_sigma,
              traceTheta=trace_theta,
              traceM=trace_M,
              traceD=trace_D,
              traceGtheta=trace_g.theta,
              traceP=trace_p,
              iterations=count,
              like=trace_like,
              like2=trace_like2,
              prior=trace_prior,
              post=trace_post,
              priorM = trace_priorM,
              priorsigma = trace_priorsigma,
              priorGammaGtheta = trace_priorGammaGtheta,
              priorTheta = trace_priorTheta))
}
